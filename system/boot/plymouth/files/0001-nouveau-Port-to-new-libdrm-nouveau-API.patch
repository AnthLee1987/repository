From f6ed8284a4b03aee0b124fbe88ae039518946175 Mon Sep 17 00:00:00 2001
From: Ikey Doherty <ikey@solusos.com>
Date: Tue, 3 Sep 2013 12:36:32 +0100
Subject: [PATCH] nouveau: Port to new libdrm nouveau API

---
 .../renderers/drm/ply-renderer-nouveau-driver.c    |   31 +++++++++++++-------
 1 file changed, 20 insertions(+), 11 deletions(-)

diff --git a/src/plugins/renderers/drm/ply-renderer-nouveau-driver.c b/src/plugins/renderers/drm/ply-renderer-nouveau-driver.c
index 2cef56e..09c8cf4 100644
--- a/src/plugins/renderers/drm/ply-renderer-nouveau-driver.c
+++ b/src/plugins/renderers/drm/ply-renderer-nouveau-driver.c
@@ -41,9 +41,8 @@
 #include <unistd.h>
 
 #include <drm.h>
+#include <nouveau.h>
 #include <nouveau_drm.h>
-#include <nouveau_drmif.h>
-#include <nouveau_bo.h>
 #include <xf86drm.h>
 #include <xf86drmMode.h>
 
@@ -69,6 +68,8 @@ struct _ply_renderer_driver
   int device_fd;
   struct nouveau_device *device;
 
+  struct nouveau_client *client;
+
   ply_hashtable_t *buffers;
 };
 
@@ -80,14 +81,21 @@ create_driver (int device_fd)
   driver = calloc (1, sizeof (ply_renderer_driver_t));
   driver->device_fd = device_fd;
 
-  if (nouveau_device_open_existing (&driver->device, true,
-                                    driver->device_fd, 0) < 0)
+  if (nouveau_device_wrap (driver->device_fd, true,
+                                    &driver->device) < 0)
     {
       ply_trace ("could not open nouveau device");
       free (driver);
       return NULL;
     }
 
+  if(nouveau_client_new (driver->device, driver->client) < 0)
+    {
+        ply_trace ("could not create nouveau client");
+        free (driver);
+        return NULL;
+    }
+    
   driver->buffers = ply_hashtable_new (ply_hashtable_direct_hash,
                                        ply_hashtable_direct_compare);
 
@@ -100,7 +108,7 @@ destroy_driver (ply_renderer_driver_t *driver)
   ply_hashtable_free (driver->buffers);
 
   ply_trace ("closing nouveau device");
-  nouveau_device_close (&driver->device);
+  nouveau_device_del (&driver->device);
   free (driver);
 }
 
@@ -221,13 +229,14 @@ create_buffer (ply_renderer_driver_t *driver,
   struct nouveau_bo *buffer_object;
   ply_renderer_buffer_t *buffer;
   uint32_t buffer_id;
+  union nouveau_bo_config cfg = {};
 
   *row_stride = ply_round_to_multiple (width * 4, 256);
 
   buffer_object = NULL;
   if (nouveau_bo_new (driver->device,
                       NOUVEAU_BO_VRAM | NOUVEAU_BO_MAP, 0,
-                      height * *row_stride, &buffer_object) < 0)
+                      height * *row_stride, &cfg, &buffer_object) < 0)
     {
       ply_trace ("Could not allocate GEM object for frame buffer: %m");
       return 0;
@@ -237,17 +246,17 @@ create_buffer (ply_renderer_driver_t *driver,
    * immediately (it's normally instantiated lazily when needed
    * by other nouveau_bo api)
    */
-  nouveau_bo_map (buffer_object, NOUVEAU_BO_WR);
+  nouveau_bo_map (buffer_object, NOUVEAU_BO_WR, driver->client);
   if (drmModeAddFB (driver->device_fd, width, height,
                     24, 32, *row_stride, buffer_object->handle,
                     &buffer_id) != 0)
     {
-      nouveau_bo_unmap (buffer_object);
+      nouveau_bo_del (buffer_object);
       ply_trace ("Could not set up GEM object as frame buffer: %m");
       nouveau_bo_ref (NULL, &buffer_object);
       return 0;
     }
-  nouveau_bo_unmap (buffer_object);
+  nouveau_bo_del (buffer_object);
 
   buffer = ply_renderer_buffer_new (driver,
                                     buffer_object, buffer_id,
@@ -270,7 +279,7 @@ map_buffer (ply_renderer_driver_t *driver,
 
   assert (buffer != NULL);
 
-  return nouveau_bo_map (buffer->object, NOUVEAU_BO_WR) == 0;
+  return nouveau_bo_map (buffer->object, NOUVEAU_BO_WR, driver->client) == 0;
 }
 
 static void
@@ -283,7 +292,7 @@ unmap_buffer (ply_renderer_driver_t *driver,
 
   assert (buffer != NULL);
 
-  nouveau_bo_unmap (buffer->object);
+  nouveau_bo_del (buffer->object);
 }
 
 static char *
-- 
1.7.10.4

