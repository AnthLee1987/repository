From 8ec56452dac5c096c6a7df45a7004104fb797154 Mon Sep 17 00:00:00 2001
From: Ikey Doherty <ikey.doherty@gmail.com>
Date: Wed, 23 Jul 2014 23:44:49 +0100
Subject: [PATCH 7/8] session: Rewrite old budgie-session in Vala

This new session binary is much more advanced than the original, and
will automatically restart elements of the Budgie Desktop as required.
It also features tighter integration with GNOME autostart concepts,
ensuring that particular parts of the desktop are activated at the
right time.
---
 session/BudgieSession.vala | 415 +++++++++++++++++++++++++++++++++++++++++++++
 session/Makefile.am        |  12 +-
 session/budgie-session.c   | 334 ------------------------------------
 3 files changed, 424 insertions(+), 337 deletions(-)
 create mode 100644 session/BudgieSession.vala
 delete mode 100644 session/budgie-session.c

diff --git a/session/BudgieSession.vala b/session/BudgieSession.vala
new file mode 100644
index 0000000..cc1024e
--- /dev/null
+++ b/session/BudgieSession.vala
@@ -0,0 +1,415 @@
+/*
+ * Session.vala
+ * 
+ * Copyright 2014 Ikey Doherty <ikey.doherty@gmail.com>
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+namespace Budgie
+{
+
+    const string WM_NAME = "budgie-wm";
+    const string PANEL_NAME = "budgie-panel";
+    /* Never attempt to relaunch something more than 3 times */
+    const int MAX_LAUNCH = 3;
+
+    /**
+     * Simple container class to monitor processes, and how many times they
+     * have been launched, etc.
+     */
+    protected class  WatchedProcess {
+
+        /** Current PID of the process */
+        public Pid pid { public get; public set; }
+
+        /** Number of times this process has been launched */
+        public int n_times { public get; public set; }
+
+         /** Command line for the process */
+        public string cmd_line { public get; public set; }
+    }
+
+/**
+ * Budgie.Session is responsible for session management within the Budgie
+ * Desktop
+ */
+public class Session : GLib.Application
+{
+
+    bool running = false;
+    GLib.MainLoop loop = null;
+    Gee.HashMap<string,WatchedProcess?> process_map;
+    // xdg mapping
+    Gee.HashMap<string,DesktopAppInfo>  mapping;
+    bool relaunch = true;
+
+    /**
+     * We only ever want to be activated once (unique instance)
+     */
+    public override void activate()
+    {
+        if (running) {
+            stdout.printf("Session already running\n");
+            return;
+        }
+
+        hold();
+        running = true;
+        prepare_xdg();
+
+        process_map = new Gee.HashMap<string,WatchedProcess?>(null,null,null);
+        launch_xdg("Initialization");
+
+        /* Launch our items - want the window manager first */
+        if (!launch_watched(WM_NAME)) {
+            critical("Unable to launch %s", WM_NAME);
+            Process.exit(1);
+        }
+        launch_xdg("WindowManager");
+
+        // Now we need all "init" style items
+        if (!launch_watched(PANEL_NAME)) {
+            critical("Unable to launch %s", PANEL_NAME);
+        }
+        // And now "panel" style items, where appropriate
+        launch_xdg("Panel");
+
+        // And now all you other fellers.
+        launch_xdg("Desktop");
+        launch_xdg("Applications");
+
+        loop.run();
+
+        release();
+    }
+
+    /**
+     * Launch a process and keep it in a monitored state
+     */
+    protected bool launch_watched(string cmdline)
+    {
+        WatchedProcess? p;
+        Pid pid;
+        int fdin, fdout, fderr;
+        string[] argv;
+        string[] environ = Environ.get();
+        string home_dir = Environment.get_home_dir();
+
+        /* Split cmdline into argv */
+        try {
+            GLib.Shell.parse_argv(cmdline, out argv);
+        } catch (GLib.ShellError e) {
+            stderr.printf("Error parsing command line: %s\n", e.message);
+            return false;
+        }
+
+        if (!process_map.has_key(cmdline)) {
+            p = new WatchedProcess();
+            p.n_times = 0;
+        } else {
+            p = process_map[cmdline];
+        }
+
+        try {
+            Process.spawn_async_with_pipes(home_dir,
+                argv, environ,
+                SpawnFlags.SEARCH_PATH | SpawnFlags.DO_NOT_REAP_CHILD,
+                null, out pid, out fdin, out fdout, out fderr);
+        } catch (SpawnError e) {
+            stderr.printf("Could not spawn command: %s\n", e.message);
+            return false;
+        }
+
+        p.pid = pid;
+        p.cmd_line = cmdline;
+        // Increment the times we've launched this fella
+        p.n_times += 1;
+        process_map[cmdline] = p;
+        /* Watch the child and see if it dies */
+        ChildWatch.add(pid, child_reaper);
+
+        return true;
+    }
+
+    /**
+     * Handle processes that died
+     */
+    protected void child_reaper(Pid pid, int status)
+    {
+        WatchedProcess? p = null;
+
+        foreach (var process in process_map.values) {
+            if (process.pid == pid) {
+                p = process;
+                break;
+            }
+        }
+
+        stdout.printf("%d (%s) closed with exit code: %d\n", pid, p.cmd_line, status);
+        stdout.printf("Launched %d times\n", p.n_times);
+
+        Process.close_pid(pid);
+        /* Relaunch borked processes only */
+        if (p.n_times < MAX_LAUNCH && status != 0 && relaunch) {
+            Idle.add(()=> {
+                launch_watched(p.cmd_line);
+                return false;
+            });
+            return;
+        } else {
+            if (status != 0) {
+                warning("Not relaunching %s as it has died 3 times already", p.cmd_line);
+                /* Now, if WM is dead or PANEL is dead we need to go bail. In future, handle
+                 * this more gracefully. Like, a failwhale. Or squirrel. >_> */
+                if (p.cmd_line == WM_NAME || p.cmd_line == PANEL_NAME) {
+                    critical("Critical desktop component %s exited with status code %d", p.cmd_line, status);
+                    do_logout();
+                    loop.quit();
+                }
+            } // otherwise it was a normal requested operation
+            process_map.unset(p.cmd_line);
+        }
+    }
+
+    /*
+     * Perform clean up work to tear down the desktop
+     */
+    private void do_logout()
+    {
+        if (!running) {
+            warning("Cannot logout as not actually running\n");
+            return;
+        }
+
+        hold();
+        // just in case sending SIGTERM results in some oddity in a watched
+        // process
+        relaunch = false;
+        // Kill processes that we explicitly own
+        foreach (var process in process_map.values) {
+            if (process.n_times < MAX_LAUNCH) {
+                Posix.kill(process.pid, ProcessSignal.TERM);
+                Process.close_pid(process.pid);
+            }
+        }
+        loop.quit();
+        release();
+    }
+
+    /**
+     * Iterate the xdg autostarts
+     */
+    private void prepare_xdg()
+    {
+        mapping = new Gee.HashMap<string,DesktopAppInfo>(null,null,null);
+
+        /* Layered from left to right - user at the end can override all */
+        var xdgdirs = Environment.get_system_config_dirs();
+        xdgdirs += Environment.get_user_config_dir();
+
+        foreach (var dir in xdgdirs) {
+            var startdir = @"$dir/autostart";
+            var file = File.new_for_path(startdir);
+            var info = file.query_file_type(FileQueryInfoFlags.NONE, null);
+            FileInfo? next_info;
+
+            if (info != FileType.DIRECTORY) {
+                continue;
+            }
+
+            try {
+                var listing = file.enumerate_children("standard::*", FileQueryInfoFlags.NONE, null);
+
+                /* Iterate children */
+                while ((next_info = listing.next_file(null)) != null) {
+                    try {
+                        var path = next_info.get_name();
+                        if (!path.has_suffix(".desktop")) {
+                            continue;
+                        }
+                        var fullpath = @"$startdir/$path";
+                        var nfile = File.new_for_path(fullpath);
+                        var cinfo = nfile.query_info("standard::*", FileQueryInfoFlags.NONE, null);
+                        if (cinfo.get_is_symlink()) {
+                            /* If this is a link to /dev/null its disabled */
+                            if (cinfo.get_symlink_target() == "/dev/null") {
+                                // Remove from the previously built table
+                                if (mapping.has_key(path)) {
+                                    mapping.unset(path);
+                                    continue;
+                                }
+                            }
+                        }
+
+                        var appinfo = new DesktopAppInfo.from_filename(fullpath);
+                        if (appinfo == null) {
+                            continue;
+                        }
+                        if (should_autostart(ref appinfo)) {
+                            /* Quite simply, always override the same .desktop file names
+                             * from the previous run for a layering effect */
+                            mapping[path] = appinfo;
+                        } else {
+                            /* Overridden layer might have changed something */
+                            if (mapping.has_key(path)) {
+                                mapping.unset(path);
+                            }
+                        }
+                    } catch (Error e) {
+                        stderr.printf("Error: %s\n", e.message);
+                    }
+                }
+            } catch (Error e) {
+                stderr.printf("Error: %s\n", e.message);
+            }
+        }
+    }
+
+    /**
+     * Launch session entries conforming to NewGnomeSession
+     * https://wiki.gnome.org/Projects/SessionManagement/NewGnomeSession
+     *
+     * Note: "Applications" is also a catch-call for anything that is *not*
+     * categorised
+     */
+    protected void launch_xdg(string condition)
+    {
+        foreach (var entry in mapping.values) {
+            bool launch = false;
+            bool monitor = false;
+            int delay = 0;
+
+            if (entry.has_key("X-GNOME-Autostart-Phase")) {
+                var phase = entry.get_string("X-GNOME-Autostart-Phase");
+                if (condition != phase) {
+                    continue;
+                }
+                launch = true;
+            } else if (condition == "Applications") {
+                launch = true;
+            }
+            // determine if we need to monitor it
+            if (entry.has_key("X-GNOME-AutoRestart")) {
+                monitor = entry.get_boolean("X-GNOME-AutoRestart");
+            }
+            // does it need a delay?
+            if (entry.has_key("X-GNOME-Autostart-Delay")) {
+                string del = entry.get_string("X-GNOME-Autostart-Delay");
+                delay = int.parse(del);
+            }
+
+            /* So, go launch it. */
+            try {
+                if (monitor) {
+                    /* Monitored processes are handled by us */
+                    if (delay > 0) {
+                        Timeout.add(delay, ()=> {
+                            launch_watched(entry.get_commandline());
+                            return false;
+                        });
+                    } else {
+                        launch_watched(entry.get_commandline());
+                    }
+                } else {
+                    if (delay > 0) {
+                        Timeout.add(delay, ()=> {
+                            entry.launch(null, null);
+                            return false;
+                        });
+                    } else {
+                        entry.launch(null, null);
+                    }
+                }
+            } catch (Error e) {
+                warning("Unable to launch item: %s", e.message);
+            }
+        }
+    }
+
+    protected bool should_autostart(ref DesktopAppInfo info)
+    {
+        bool ret = false;
+        /* First condition, check we should show */
+        if (info.has_key("OnlyShowIn")) {
+            var showin = info.get_string("OnlyShowIn");
+            if ("Budgie;" in showin || "GNOME;" in showin) {
+                ret = true;
+            } else {
+                ret = false;
+            }
+        }
+
+        if (!ret) {
+            return ret;
+        }
+
+        /* Secondly, determine if its a gsettings key step */
+        if (info.has_key("AutostartCondition")) {
+            var splits = info.get_string("AutostartCondition").split(" ", 3);
+            if (splits[0] != "GSettings") {
+                return false;
+            }
+            var settings = new Settings(splits[1]);
+            return settings.get_boolean(splits[2]) == true;
+        }
+        return true;
+    }
+
+    private Session()
+    {
+        Object (application_id: "com.evolve_os.BudgieSession", flags: 0);
+        loop = new MainLoop(null, false);
+
+        var action = new SimpleAction("logout", null);
+        action.activate.connect(()=> {
+            do_logout();
+        });
+        add_action(action);
+    }
+
+    static bool should_logout = false;
+
+	private const GLib.OptionEntry[] options = {
+        { "logout", 0, 0, OptionArg.NONE, ref should_logout, "Logout", null },
+        { null }
+    };
+
+    /**
+     * Main entry   
+     */
+    public static int main(string[] args)
+    {
+        Budgie.Session app;
+
+        try {
+            var opt_context = new OptionContext("- Budgie Session");
+            opt_context.set_help_enabled(true);
+            opt_context.add_main_entries(options, null);
+            opt_context.parse(ref args);
+        } catch (OptionError e) {
+            stdout.printf("Error: %s\nRun with --help to see valid options\n", e.message);
+            return 0;
+        }
+
+        app = new Budgie.Session();
+
+        if (should_logout) {
+            try {
+                app.register(null);
+                app.activate_action("logout", null);
+                Process.exit(0);
+            } catch (Error e) {
+                stderr.printf("Error activating logout: %s\n", e.message);
+                return 1;
+            }
+        }
+
+        return app.run(args);
+    }
+} // End Session
+
+} // End Budgie namespace
diff --git a/session/Makefile.am b/session/Makefile.am
index df2a9e7..e966807 100644
--- a/session/Makefile.am
+++ b/session/Makefile.am
@@ -18,16 +18,22 @@ libsdloginproxy_la_LIBADD = \
 	$(GIO_UNIX_LIBS)
 
 budgie_session_SOURCES = \
-	budgie-session.c
+	BudgieSession.vala
 
 budgie_session_CFLAGS = \
 	$(GIO_CFLAGS) \
 	$(GIO_UNIX_CFLAGS) \
-	$(AM_CFLAGS)
+	$(GEE_CFLAGS)
 
 budgie_session_LDADD = \
 	$(GIO_LIBS) \
-	$(GIO_UNIX_LIBS)
+	$(GIO_UNIX_LIBS) \
+	$(GEE_LIBS)
+
+budgie_session_VALAFLAGS = \
+	--pkg gio-unix-2.0 \
+	--pkg gee-0.8 \
+	--pkg posix
 
 budgie_session_dialog_SOURCES = \
 	../data/budgie-session-dialog-resources.h \
diff --git a/session/budgie-session.c b/session/budgie-session.c
deleted file mode 100644
index 04edd5b..0000000
--- a/session/budgie-session.c
+++ /dev/null
@@ -1,334 +0,0 @@
-/*
- * budgie-session.c
- * 
- * Copyright 2013 Ikey Doherty <ikey.doherty@gmail.com>
- * 
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <gio/gio.h>
-#include <gio/gdesktopappinfo.h>
-#include <sys/wait.h>
-#include "common.h"
-
-#define BUDGIE_SESSION_ID "com.evolve_os.BudgieSession"
-#define ACTION_LOGOUT "logout"
-
-#define DESKTOP_WM "budgie-wm"
-
-#define DESKTOP_PANEL "budgie-panel"
-
-static gboolean activated = FALSE;
-static gboolean should_exit = FALSE;
-
-/**
- * Activate all autostart entries
- * Note this is only done via SYSTEM directories, we currently DO NOT
- * support user-specific (~/.config/autostart) entries yet, as we'd
- * have to track what's been launched, and what to ignore, order of
- * execution, etc.
- */
-static void activate_autostarts(void);
-
-/**
- * Whether or not we should attempt to execute this entry.
- */
-static gboolean should_autostart(GDesktopAppInfo *info);
-
-/**
- * Whether the autostart condition is satisfied
- */
-static gboolean is_autostart_condition_satisfied(GDesktopAppInfo *info);
-
-/**
-* Iterate a null terminated array
-*/
-#define foreach_string(x,y,i) const char *y = NULL;int i;\
-for (i=0; (y = *(x+i)) != NULL; i++ )
-
-static void activate(GApplication *application, gpointer userdata)
-{
-        if (activated) {
-                return;
-        }
-
-        GError *error = NULL;
-        gint exit = 0;
-        GPid pid;
-        __attribute__ ((unused)) int c_ret;
-        gchar **p_argv = NULL;
-        int wID;
-        const gchar *home_dir;
-
-        home_dir = g_get_home_dir();
-
-        /* Need to pass an argv to g_spawn_async */
-        if (!g_shell_parse_argv(DESKTOP_WM, NULL, &p_argv, &error)) {
-                fprintf(stderr, "g_shell_parse_argv() failed\n");
-                g_error_free(error);
-                return;
-        }
-
-        /* Launch WM immediately async, so we can start other display
-         * dependant child processes */
-        if (!g_spawn_async(home_dir, p_argv, NULL,
-                G_SPAWN_STDOUT_TO_DEV_NULL | G_SPAWN_STDERR_TO_DEV_NULL |
-                G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_SEARCH_PATH,
-                NULL, NULL, &pid, &error)) {
-                fprintf(stderr, "Unable to launch window manager: %s\n",
-                        error->message);
-                fprintf(stderr, "Child exited with code %d\n", exit);
-                goto end;
-        }
-
-        /* Give the window manager a second to sort itself out */
-        sleep(1);
-
-        /* Ensures things like gnome-settings-daemon launch *after* the
-         * window manager but before the panel */
-        activate_autostarts();
-
-        /* Launch panel component */
-        if (!g_spawn_command_line_async(DESKTOP_PANEL, &error)) {
-                fprintf(stderr, "Unable to launch panel: %s\n",
-                        error->message);
-                goto end;
-        }
-
-        activated = TRUE;
-        g_application_hold(application);
-
-        /* Now we wait for previously async-launched WM to exit */
-        while (TRUE) {
-                /* Logout requested */
-                if (should_exit) {
-                        goto child_end;
-                }
-
-                wID = waitpid(pid, &c_ret, WNOHANG|WUNTRACED);
-                if (wID < 0) {
-                        fprintf(stderr, "waitpid(%d) failure. Aborting\n",
-                                wID);
-                        goto child_end;
-                } else if (wID == 0) {
-                        g_main_context_iteration(NULL, TRUE);
-                } else if (wID == pid) {
-                        break;
-                }
-        }
-child_end:
-        g_spawn_close_pid(pid);
-        g_application_release(application);
-end:
-        if (error) {
-                g_error_free(error);
-        }
-        if (p_argv) {
-                g_strfreev(p_argv);
-        }
-}
-
-static void logout_cb(GAction *action,
-                      GVariant *param,
-                      gpointer userdata)
-{
-        GApplication *application;
-
-        application = G_APPLICATION(userdata);
-        g_application_hold(application);
-        /* Mark process for exit */
-        should_exit = TRUE;
-        g_application_release(application);
-}
-
-static void activate_autostarts(void)
-{
-        const gchar * const *xdg_system = NULL;
-        char *path = NULL;
-
-        GFileType type;
-        GFile *file = NULL;
-        GFileInfo *next_file = NULL;
-        GFileEnumerator *listing = NULL;
-        const gchar *next_path;
-        gchar *full_path;
-
-        GDesktopAppInfo *app_info = NULL;
-
-        xdg_system = g_get_system_config_dirs();
-        if (!xdg_system) {
-                g_warning("Unable to determine xdg system directories. Not autostarting applications\n");
-                return;
-        }
-
-        /* Iterate each entry and launch all items in these directories */
-        foreach_string(xdg_system, dir, i) {
-                path = g_strdup_printf("%s/autostart", dir);
-                if (!path) {
-                        /* OOM */
-                        abort();
-                }
-
-                /* Check we have a directory */
-                file = g_file_new_for_path(path);
-                type = g_file_query_file_type(file, G_FILE_QUERY_INFO_NONE, NULL);
-                if (type != G_FILE_TYPE_DIRECTORY) {
-                        goto next;
-                }
-
-                /* Enumerate this directory */
-                listing = g_file_enumerate_children(file, "standard::*", G_FILE_QUERY_INFO_NONE,
-                        NULL, NULL);
-
-                while ((next_file = g_file_enumerator_next_file(listing, NULL, NULL)) != NULL) {
-                        next_path = g_file_info_get_name(next_file);
-
-                        /* Only interested in .desktop files */
-                        if (!g_str_has_suffix(next_path, ".desktop")) {
-                                continue;
-                        }
-                        full_path = g_strdup_printf("%s/%s", path, next_path);
-
-                        /* Try to load it as a valid desktop file */
-                        app_info = g_desktop_app_info_new_from_filename((const char*)full_path);
-                        if (!app_info) {
-                                goto failed;
-                        }
-
-                        /* Now launch it */
-                        /* Eventually we're going to need a global launch context
-                         * within Budgie. */
-                        if (should_autostart(app_info)) {
-                                if (!g_app_info_launch(G_APP_INFO(app_info), NULL, NULL, NULL)) {
-                                        g_warning("Failed to launch: %s\n", full_path);
-                                }
-                        }
-
-                        g_object_unref(app_info);
-failed:
-                        g_free(full_path);
-                        g_object_unref(next_file);
-                }
-                g_file_enumerator_close(listing, NULL, NULL);
-next:
-                g_object_unref(file);
-                g_free(path);
-        }
-}
-
-static gboolean should_autostart(GDesktopAppInfo *info)
-{
-        g_assert(info != NULL);
-
-        gboolean should_start = FALSE;
-        gchar *show_in;
-
-        if (g_desktop_app_info_has_key(info, "OnlyShowIn")) {
-                show_in = g_desktop_app_info_get_string(info, "OnlyShowIn");
-                /* Determine if its a GNOME or Budgie system */
-                if (string_contains((const gchar*)show_in, "GNOME;") ||
-                        string_contains((const gchar*)show_in, "Budgie;")) {
-                        should_start = TRUE;
-                }
-                g_free(show_in);
-        } else {
-                /* Normal autostart - woo */
-                should_start = TRUE;
-        }
-
-        if (!should_start) {
-                goto end;
-        }
-
-        if (is_autostart_condition_satisfied(info)) {
-                should_start = TRUE;
-        } else {
-                should_start = FALSE;
-        }
-
-        /* TODO: Support delay/init conditions */
-end:
-        return should_start;
-}
-
-static gboolean is_autostart_condition_satisfied(GDesktopAppInfo *info)
-{
-        g_assert(info != NULL);
-
-        gchar *condition;
-        gchar **splits = NULL;
-        gboolean satisfied = FALSE;
-        const gchar *schema;
-        const gchar *key;
-        GSettings *settings = NULL;
-
-        /* AutostartCondition=GSettings org.gnome.desktop.background show-desktop-icons */
-        if (!g_desktop_app_info_has_key(info, "AutostartCondition")) {
-                return TRUE;
-        }
-
-        condition = g_desktop_app_info_get_string(info, "AutostartCondition");
-        splits = g_strsplit(condition, " ", 3);
-
-        if (!g_str_equal(splits[0], "GSettings")) {
-                goto clean;
-        }
-
-        schema = splits[1];
-        key = splits[2];
-
-        settings = g_settings_new(schema);
-        if (g_settings_get_boolean(settings, key) == TRUE) {
-                satisfied = TRUE;
-        } else {
-                satisfied = FALSE;
-        }
-
-        g_object_unref(settings);
-clean:
-        g_free(condition);
-        g_strfreev(splits);
-
-        return satisfied;
-}
-
-gint main(gint argc, gchar **argv)
-{
-        GApplication *app = NULL;
-        GSimpleAction *action = NULL;
-        int status = 0;
-
-        g_setenv("DESKTOP_SESSION", "gnome", TRUE);
-
-        app = g_application_new(BUDGIE_SESSION_ID, G_APPLICATION_FLAGS_NONE);
-        g_signal_connect(app, "activate", G_CALLBACK(activate), NULL);
-
-        /* Logout action */
-        action = g_simple_action_new(ACTION_LOGOUT, NULL);
-        g_signal_connect(action, "activate", G_CALLBACK(logout_cb), app);
-        g_action_map_add_action(G_ACTION_MAP(app), G_ACTION(action));
-        g_object_unref(action);
-
-        /* TODO: Use opts!! */
-        if (argc > 1) {
-                if (g_str_equal(argv[1], "--logout")) {
-                        g_application_register(app, NULL, NULL);
-                        g_action_group_activate_action(G_ACTION_GROUP(app),
-                                ACTION_LOGOUT, NULL);
-                } else {
-                        printf("Unknown command: %s\n", argv[1]);
-                        return EXIT_FAILURE;
-                }
-        } else {
-                status = g_application_run(app, argc, argv);
-        }
-
-        g_object_unref(app);
-
-        return status;
-}
-- 
1.9.1

